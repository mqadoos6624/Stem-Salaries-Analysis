# -*- coding: utf-8 -*-
"""Data Mining Final Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12HtlVs-8J-_Qjb9m5NKd2RqVb2zm4_wP
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import calendar

#Alaaldin Dwaik , Nabil Shawkat, Muhammad Qadoos

#https://www.kaggle.com/jackogozaly/data-science-and-stem-salaries
df = pd.read_csv('Levels_Fyi_Salary_Data.csv')
df.head(10)

df.describe()

df.dtypes

def getBoxPlotFences(dt,showBoxPlot=False):
  Q1 = dt.quantile(0.25)
  Q3 = dt.quantile(0.75)
  IQR = Q3 - Q1

  Lower_Fence = Q1 - (1.5 * IQR)
  Upper_Fence = Q3 + (1.5 * IQR)

  if showBoxPlot:
    plt.figure(figsize=(20,5))
    bp =  plt.boxplot(dt,vert=False)

  return Lower_Fence,Upper_Fence

#for all (String) , Strip + toLower
df_obj = df[['company','level','title','tag','otherdetails']]
df[df_obj.columns] = df_obj.apply(lambda x: x.str.strip())
df[df_obj.columns] = df_obj.apply(lambda x: x.str.lower())

"""# Columns Cleaning"""

#drop non-US based records (using location column)

x = df[df['location'].str.match('^.+,(\s)*[a-zA-Z]{2}$') == False]['location']
x = x.index
print(f'to be dropped {len(x)}')
df = df.drop(index=x)
df.reset_index(drop=True, inplace=True)

#timestamp ; we need to extract (year,Month) from the column

df['year'] = pd.DatetimeIndex(df['timestamp']).year
df['month'] = pd.DatetimeIndex(df['timestamp']).month

#company; column is clean

x = df['company'].str.match('[A-Za-z\s]+')
x = list(x[x == False].index)
print(len(x))
print(df.iloc[x]['company'].unique())

#sounds ok <column is clean>

#level ; we are not sure about the levels that are provided here, mostly they are not standard

len(df['level'].unique())

#title; seems to be ok

print(df['title'].unique())

# x = df.groupby('title').size()
# plt.figure(figsize=(20,10))
# plt.pie(x.values,labels=x.index)
# plt.tight_layout()

#totalyearlycompensation ; we have some outliers due to the fact that totalyearlycompensation is the sum of (salary,stock and bonus);

# in ML phase , we need to standardize the values , and remove the outliers if required
# for almost 10K records , we have wrong sum, so we need to re sum the value using (salary,stock and bonus)
# for almost 2K we have a value without corrosponding values in (salary,stock and bonus). we need to keep it and fill (salary,stock and bonus) 
#                                                                                         based on the distribution for other records


#############
# Decision
#############
# in case when totalyearlycompensation != sum(salary,stock and bonus),  we have the following cases :

# when totalyearlycompensation > sum(salary,stock and bonus)
#   when totalyearlycompensation is available and  (salary,stock and bonus) are 0 ==> distribute over the 3 cols
#   when totalyearlycompensation is available and salary is 0 and (bonus or stock) are not 0 ==> fill difference into base salary
#   when totalyearlycompensation is available and salary is available ==> distribute the diff over (bonus and stock)

#when totalyearlycompensation < sum(salary,stock and bonus); re Sum totalyearlycompensation

# when totalyearlycompensation < sum(salary,stock and bonus)
cond = df['totalyearlycompensation'] < (df['basesalary'] + df['stockgrantvalue']+df['bonus'])
df.loc[cond,'totalyearlycompensation'] = df['basesalary'] + df['stockgrantvalue']+df['bonus']

#get (salary,stock and bonus) weights
weights = df[['basesalary','stockgrantvalue','bonus']].copy()
tot = df['basesalary'] + df['stockgrantvalue'] + df['bonus']

weights['basesalary_w'] = weights['basesalary'] / tot
weights['stockgrantvalue_w'] = weights['stockgrantvalue'] / tot
weights['bonus_w'] = weights['bonus'] / tot

weights = weights[['basesalary_w','stockgrantvalue_w','bonus_w']]
weights.fillna(0,inplace=True)
weights = weights.sum(axis=0)
weights = weights / weights.sum(axis=0)
weights.rename({'basesalary_w':'basesalary','stockgrantvalue_w':'stockgrantvalue','bonus_w':'bonus'},inplace=True)
weights

# when totalyearlycompensation > sum(salary,stock and bonus)
cond = df['totalyearlycompensation'] > (df['basesalary'] + df['stockgrantvalue']+df['bonus'])

#   (1) when totalyearlycompensation is available and  (salary,stock and bonus) are 0 ==> distribute over the 3 cols
sub_cond = df['basesalary'] + df['stockgrantvalue'] + df['bonus'] == 0

df.loc[cond & sub_cond, 'basesalary'] = df['totalyearlycompensation'] * weights['basesalary']
df.loc[cond & sub_cond, 'stockgrantvalue'] = df['totalyearlycompensation'] * weights['stockgrantvalue']
df.loc[cond & sub_cond, 'bonus'] = df['totalyearlycompensation'] * weights['bonus']

#   (2) when totalyearlycompensation is available and salary is 0 and (bonus or stock) are not 0 ==> fill difference into base salary
sub_cond = (df['basesalary'] == 0) & (df['stockgrantvalue'] + df['bonus'] != 0)
df.loc[cond & sub_cond, 'basesalary'] = df['totalyearlycompensation'] - (df['stockgrantvalue'] + df['bonus'])

#   (3) when totalyearlycompensation is available and salary is available ==> distribute the diff over (bonus and stock)
sub_cond = (df['basesalary'] != 0)

sub_weights = weights[['stockgrantvalue','bonus']]
sub_weights = sub_weights /sub_weights.sum()

df.loc[cond & sub_cond, 'stockgrantvalue'] = (df['totalyearlycompensation'] - df['basesalary']) * sub_weights['stockgrantvalue']
df.loc[cond & sub_cond, 'bonus'] = (df['totalyearlycompensation'] - df['basesalary']) * sub_weights['bonus']

#finally , round and convert to int , then Re-Sum totalyearlycompensation
df = df.astype({"basesalary": int, "stockgrantvalue": int,'bonus':int})
df['totalyearlycompensation'] = df['basesalary'] + df['stockgrantvalue'] + df['bonus']

print(f'column type is: {df.dtypes["totalyearlycompensation"]}')
Cnulls = df['totalyearlycompensation'].isnull()
print(f'# of nulls: {len(Cnulls[Cnulls == True])}')
print(f'min:{df["totalyearlycompensation"].min():,},max:{df["totalyearlycompensation"].max():,}')
print()

x = df['totalyearlycompensation']
print(f'avg: {x.mean():0,.2f}')


Q1 = x.quantile(0.25)
Q3 = x.quantile(0.75)
IQR = Q3 - Q1

Lower_Fence = Q1 - (1.5 * IQR)
Upper_Fence = Q3 + (1.5 * IQR)

print(f'Lower_Fence:{Lower_Fence:,},Upper_Fence:{Upper_Fence:,}')

l = x[x > Upper_Fence]
print(f'outliers # : {len(l):,}')


plt.figure(figsize=(20,5))
bp =  plt.boxplot(x,vert=False)


#resum wrong values
ix = df[(df['totalyearlycompensation'] != df['basesalary'] + df['stockgrantvalue'] + df['bonus']) & df['basesalary'] + df['stockgrantvalue'] + df['bonus'] != 0 ]
ix = ix.index
df.iloc[ix]

#location; extract city,state values into two columns

df['city'] = df['location'].str.extract(r'^(.+)(?=,)')
df['state'] = df['location'].str.extract(r'(?<=\,)(.+)')

df['city'] = df['city'].str.strip()
df['state'] = df['state'].str.strip()

# for both yearsofexperience & yearsatcompany ; we need to fix mismatch

#update yearsofexperience to match atleast yearsatcompany

df[(df['yearsofexperience'] > 0) &  (df['yearsatcompany'] == 0)]

df[df['yearsofexperience'] < df['yearsatcompany']]

#yearsofexperience; some values are 0' , we need to figure out how to substitute these ! <seems to be Unknown , or missing>

print(df['yearsofexperience'].unique())

df[df['yearsofexperience'] == 0.]

#yearsatcompany ; the same problem as the previous

print(df['yearsatcompany'].unique())
df[df['yearsatcompany'] == 0.]

#tag ; it is like the level , it is hard to summarize these

list(df['tag'].unique())

#basesalary

print(f'column type is: {df.dtypes["basesalary"]}')
Cnulls = df['basesalary'].isnull()
print(f'# of nulls: {len(Cnulls[Cnulls == True])}')
print(f'min:{df["basesalary"].min():,},max:{df["basesalary"].max():,}')
print()
print(df['basesalary'].describe())
x = df['basesalary']
print(f'avg: {x.mean():0,.2f}')


Q1 = x.quantile(0.25)
Q3 = x.quantile(0.75)
IQR = Q3 - Q1

Lower_Fence = Q1 - (1.5 * IQR)
Upper_Fence = Q3 + (1.5 * IQR)

print(f'Lower_Fence:{Lower_Fence:,},Upper_Fence:{Upper_Fence:,}')

uV = x[x > Upper_Fence]
lV =  x[x < Lower_Fence]
print(f'outliers # :L:{len(lV)} + U:{len(uV)}  =  {len(uV)+len(lV):,}')


plt.figure(figsize=(20,5))
bp =  plt.boxplot(x,vert=False)

#stockgrantvalue

print(f'column type is: {df.dtypes["stockgrantvalue"]}')
Cnulls = df['stockgrantvalue'].isnull()
print(f'# of nulls: {len(Cnulls[Cnulls == True])}')
print(f'min:{df["stockgrantvalue"].min():,},max:{df["stockgrantvalue"].max():,}')
print()
print(df['stockgrantvalue'].describe())
x = df['stockgrantvalue']
print(f'avg: {x.mean():0,.2f}')


Q1 = x.quantile(0.25)
Q3 = x.quantile(0.75)
IQR = Q3 - Q1

Lower_Fence = Q1 - (1.5 * IQR)
Upper_Fence = Q3 + (1.5 * IQR)

print(f'Lower_Fence:{Lower_Fence:,},Upper_Fence:{Upper_Fence:,}')

uV = x[x > Upper_Fence]
lV =  x[x < Lower_Fence]
print(f'outliers # :L:{len(lV)} + U:{len(uV)}  =  {len(uV)+len(lV):,}')


plt.figure(figsize=(20,5))
bp =  plt.boxplot(x,vert=False)

#bonus

print(f'column type is: {df.dtypes["bonus"]}')
Cnulls = df['bonus'].isnull()
print(f'# of nulls: {len(Cnulls[Cnulls == True])}')
print(f'min:{df["bonus"].min():,},max:{df["bonus"].max():,}')
print()
print(df['bonus'].describe())
x = df['bonus']
print(f'avg: {x.mean():0,.2f}')


Q1 = x.quantile(0.25)
Q3 = x.quantile(0.75)
IQR = Q3 - Q1

Lower_Fence = Q1 - (1.5 * IQR)
Upper_Fence = Q3 + (1.5 * IQR)

print(f'Lower_Fence:{Lower_Fence:,},Upper_Fence:{Upper_Fence:,}')

uV = x[x > Upper_Fence]
lV =  x[x < Lower_Fence]
print(f'outliers # :L:{len(lV)} + U:{len(uV)}  =  {len(uV)+len(lV):,}')


plt.figure(figsize=(20,5))
bp =  plt.boxplot(x,vert=False)

#gender

x = df.groupby('gender',dropna=False).size()
plt.pie(x.values,labels=x.index)

cond = (df['gender'] == 'Male') | (df['gender'] == 'Female') | (df['gender'] == 'Other')
x = df['gender'].where(cond,'Unknown')
x.name = 'gender'

df.update(x)

x = df.groupby('gender',dropna=False).size()
plt.pie(x.values,labels=x.index)

#otherdetails; a lot of unstarded values

list(df['otherdetails'].unique())

#cityid	dmaid	rowNumber - we dont need these

#education; seems to be ok ; we need to take a look at nulls

x = df.groupby('Education',dropna=False).size()
print(x)
plt.pie(x.values,labels=x.index)

df['Education'] = df['Education'].fillna('UnKnown')

df[df['Education'].isnull() & (df['Masters_Degree']+ df['Bachelors_Degree']	+df['Doctorate_Degree'] +df['Highschool']	+df['Some_College'] > 0)]

#Race; seems to be ok

x = df.groupby('Race',dropna=False).size()
print(x)
plt.pie(x.values,labels=x.index)

df['Race'] = df['Race'].fillna('UnKnown')

df[df['Race'].isnull() & (df['Race_Asian']+ df['Race_White']	+df['Race_Two_Or_More'] +df['Race_Black']	+df['Race_Hispanic'] > 0)]

len(list(df['state'].unique()))

df['state'].unique()

"""Answering

# Q1: What are the base salary trends in the top 5 states by race?
### Execlude (UnKnown Race) and filter out the outliers
### Execlude any state with less than 5 records
"""

cond_Unknow = df['Race'] != 'UnKnown'

res = df.loc[cond_Unknow,['state','Race','basesalary']]

Lower_Fence,Upper_Fence = getBoxPlotFences(res['basesalary'].copy())
print(f'Lower_Fence: {Lower_Fence},Upper_Fence:{Upper_Fence}')

res = res.copy()
res.loc[res['basesalary'] > Upper_Fence,'basesalary'] = Upper_Fence
res.loc[res['basesalary'] < Lower_Fence,'basesalary'] = Lower_Fence


#get valid states with >= 5 records
ValidStates = res.groupby('state').size()
ValidStates = ValidStates[ValidStates >= 5]
ValidStates = list(ValidStates.index)

cond_validStates = res['state'].apply(lambda x:x in ValidStates)
res = res[cond_validStates]

#get top 5 states bases on the avg of basesalary
top5_df = res.groupby('state').mean('basesalary').sort_values('basesalary',ascending=False)['basesalary'].head(5)
top5 = list(top5_df.index)

#set filters to get the top 5 states & to execlude 'UnKnown' Race (it does not make sense to be presented)
cond = res['state'].apply(lambda x:x in top5)

#get the results based on the filters
res = res.loc[cond,['state','Race']]
res = res.groupby(['state','Race']).size()
res = res / res.groupby('state').sum() # get percentage of each race

#Convert to DF
res_df = res.to_frame(name='cnt')

#Pivot DF
res_df = res_df.pivot_table('cnt',['state'],'Race')
res_df.reset_index(inplace=True)

#Plot
res_df.plot(x='state',y=list(res_df.columns).remove('state'),kind='bar',figsize=(12,8),
            title='Race (AVG Salary) Trends among the top 5 States (Only Records with Reported Race)',xlabel='Race',ylabel='Percentage')

"""# Q2: What are the trends in base salaries (avg) over months across the years (group by YYYY-MM) by (Experience Level)?

"""

res = df.loc[:,['year','month','yearsofexperience','basesalary']]
#fliter outliers
Lower_Fence,Upper_Fence = getBoxPlotFences(res['basesalary'].copy())
print(f'Lower_Fence: {Lower_Fence},Upper_Fence:{Upper_Fence}')

res = res.copy()
res.loc[res['basesalary'] > Upper_Fence,'basesalary'] = Upper_Fence
res.loc[res['basesalary'] < Lower_Fence,'basesalary'] = Lower_Fence

bins = [0,3,5,np.inf]
names = ['Junior','Mid-Level','Senior']
res['yearsofexperience'] = pd.cut(res['yearsofexperience'], bins, labels=names)
res.rename(columns = {'yearsofexperience':'Level'},inplace=True)

res = res.groupby(['year','month','Level']).mean('basesalary')['basesalary']

df_res = res.to_frame(name='average basesalary').reset_index()
df_res['month_abbr'] = df_res['month'].apply(lambda x: calendar.month_abbr[x])

df_res['label'] = df_res['year'].astype(str) +' '+ df_res['month_abbr'] 
df_res = df_res.drop(['year','month','month_abbr'],axis=1)

# Pivot DF
df_res = df_res.pivot_table('average basesalary',['label'],'Level')
df_res.columns = df_res.columns.astype(str)
df_res.reset_index(inplace=True)

#Plot
df_res.plot(x='label',y=list(df_res.columns).remove('label'),kind='line',figsize=(12,8),
            title='Trends in Reported Base-Salary month by month by Experience Level',xlabel='Month',ylabel='Average Base-Salary')

"""# Q3 :What are the trends in base salaries (avg) among genders across the past period (group by YYYY-MM)?
### execlude Unknown / Un-Reported Gender
"""

cond = df['gender'] != 'Unknown' # execlude Unknown or Un Reported Gender
cond_Other = df['gender'] != 'Other' # execlude Unknown or Un Reported Gender

res = df.loc[cond & cond_Other]

#filter out outliers
Lower_Fence,Upper_Fence = getBoxPlotFences(res['basesalary'].copy())
print(f'Lower_Fence: {Lower_Fence},Upper_Fence:{Upper_Fence}')

res = res.copy()
res.loc[res['basesalary'] > Upper_Fence,'basesalary'] = Upper_Fence
res.loc[res['basesalary'] < Lower_Fence,'basesalary'] = Lower_Fence


res = res.groupby(['year','month','gender']).mean('basesalary')['basesalary']
df_res = res.to_frame(name = 'average basesalary')
df_res.reset_index(inplace=True)

df_res
# #get label (YY-MM)
# df_res['month_abbr'] = df_res['month'].apply(lambda x: calendar.month_abbr[x])
# df_res['label'] = df_res['year'].astype(str) +' '+ df_res['month_abbr'] 
# df_res = df_res.drop(['year','month','month_abbr'],axis=1)

# #Prepaid the results
# df_res = df_res.pivot_table('average basesalary','label','gender')
# df_res.reset_index(inplace=True)

# #Plot
# df_res.plot(x='label',y=list(df_res.columns).remove('label'),kind='line',figsize=(12,5)
#             ,title='Trends in Reported Base-Salary among Reported Genders month by month',xlabel= 'Month',ylabel='Average Base-Salary')

"""# Q4: What is the distribution of levels (y of exp) among the top 10 companies?

"""

validComp = df.groupby('company').size()
validComp = validComp[validComp >= 10]
validComp = list(validComp.index)
cond_validComp = df['company'].apply(lambda x:x in validComp)

res = df[cond_validComp]

#filter out the outliers
Lower_Fence,Upper_Fence = getBoxPlotFences(res['basesalary'].copy())
print(f'Lower_Fence: {Lower_Fence},Upper_Fence:{Upper_Fence}')

res = res.copy()
res.loc[res['basesalary'] > Upper_Fence,'basesalary'] = Upper_Fence
res.loc[res['basesalary'] < Lower_Fence,'basesalary'] = Lower_Fence


top10 = res.groupby('company').mean('basesalary')['basesalary'].sort_values(ascending=False).head(10)
top10Comp = list(top10.index)

cond = df['company'].apply(lambda x:x in top10Comp)

res = df[cond].copy()
bins = [0,3,5,np.inf]
names = ['Junior','Mid-Level','Senior']

res['Lvls'] = pd.cut(res['yearsofexperience'], bins, labels=names)
res = res.groupby(['company','Lvls']).mean('basesalary')['basesalary']
# print(res)
res_df = res.to_frame(name='average basesalary')
res_df.reset_index(inplace=True)

res_df = res_df.pivot_table('average basesalary','company','Lvls')
res_df.columns = res_df.columns.astype(str)
res_df.reset_index(inplace=True)

res_df.plot(x='company',y=list(res_df.columns).remove('company'),kind='bar',figsize=(12,5)
            ,title='Trends in Reported Base-Salary among Top 10 Comapnies ',xlabel= 'Company',ylabel='Average Base-Salary')

"""# Q5: What are the Top companies with racial diversity (based on distribution of each race)? (Exclude others)
### the idea is to try to find the expected weight of each race (execlude UnKnown), then find the extra weight of each company
#### sort ascending to get the companies with lowest extra weights for races 

"""

cond_race = df['Race'] != 'UnKnown'
# cond_2orM = df['Race'] != 'Two Or More'


res = df[cond_race]

NofRaces = len(list(res['Race'].unique()))
print(NofRaces)


#get only companies with atleast 10 records <remove unwanted records>
validComp = res.groupby('company').size()
validComp = validComp[validComp >= 10]
validComp = list(validComp.index)


cond_validComp = res['company'].apply(lambda x:x in validComp)

res = res[cond_validComp].groupby(['company','Race']).size()
res = (res / res.groupby('company').sum()) - (1/NofRaces)
res_df = res.to_frame('diff')
res_df.reset_index(inplace=True)

res_df = res_df.loc[res_df['diff'] >= 0,['company','diff']]
res_df = res_df.groupby('company').sum()['diff']
res_df = res_df.sort_values()

top10 = res_df.head(10)
top10 = list(top10.index)



cond = df['company'].apply(lambda x:x in top10)
res = df[cond & cond_race][['company','Race']].groupby(['company','Race']).size()
res = res / res.groupby('company').sum()
res_df = res.to_frame(name = 'percentage')
res_df.reset_index(inplace=True)

res_df = res_df.pivot_table('percentage','company','Race')
res_df.reset_index(inplace=True)

res_df.plot(x='company',y=list(res_df.columns).remove('company'),kind='bar',figsize=(12,5)
            ,title='Top 10 Diverse Companies ',xlabel= 'Company',ylabel='Race Percentage')

"""# Q6 : What are the top 5 states based on base salaries (avg)?  

"""

#Get rid of outliers in total yearly compensation and base salary column
x = df['totalyearlycompensation']
Lower_Fence, Upper_Fence = getBoxPlotFences(x)
df1 = df[(x<=Upper_Fence) & (x>Lower_Fence)]

x1 = df1['basesalary']
Lower_Fence,Upper_Fence = getBoxPlotFences(x1)
df1 = df1[(x1<=Upper_Fence) & (x1>Lower_Fence)]

ValidStates = df1.groupby('state').size()
ValidStates = ValidStates[ValidStates >= 5]
ValidStates = list(ValidStates.index)
cond_validStates = df1['state'].apply(lambda x:x in ValidStates)
df1 = df1[cond_validStates]

avg_sal = df1.groupby("state").mean()["basesalary"]
avg_sal_5 = avg_sal.sort_values(ascending=False).head(5)
avg_sal_5

plt.barh(avg_sal_5.index, avg_sal_5.values)
plt.title('Top 5 states based on base salary')
plt.ylabel('States')
plt.xlabel('Average Base Salary')

"""# Q7 : What is the average base salary by degree level? (Exclude others)



"""

avg_sal_edu = df1.groupby("Education").mean()["basesalary"]
# i = avg_sal_5[avg_sal_5["Education"] != "UnKnown"]
Edu_comp = avg_sal_edu[avg_sal_edu.index != "UnKnown"]
Edu_comp
plt.plot(Edu_comp.index, Edu_comp.values)
plt.title('Average Base salary by Education Level')
plt.xlabel('Education Level')
plt.ylabel('Average Base Salary')
plt.xticks([0.0,1.0,2.0,3.0,4.0],["Bachelor's",'High-School',"Master's","PhD", "Some-College"])
plt.grid(True)

plt.pie(Edu_comp, labels = Edu_comp.index, autopct = "%0.2f%%" )
plt.axis("equal")

"""# Q8 : What is the top title for the top 5 states based on salary (avg)?


"""

top_state = (df1.groupby("state").mean()["basesalary"]).sort_values(ascending = False).head(6)
top_state = list(top_state.index)
top_state

fig = plt.figure(figsize=(14,14))

fig.suptitle("Top Titles for the Top Six States Based on Salary")

axes1 = fig.add_subplot(321)
axes2 = fig.add_subplot(322)
axes3 = fig.add_subplot(323)
axes4 = fig.add_subplot(324)
axes5 = fig.add_subplot(325)
axes6 = fig.add_subplot(326)
count = 1
            
for i in top_state:
    level_state = df1[df1["state"] == i]
    level_state = level_state.groupby("title").mean()["basesalary"].sort_values(ascending = False).head(5)
    level_state
    if count == 1:
        axes1.bar(level_state.index,level_state.values)
        for tick in axes1.get_xticklabels():
            tick.set_rotation(15)
    elif count == 2:
        axes2.bar(level_state.index,level_state.values)
        for tick in axes2.get_xticklabels():
            tick.set_rotation(15)
    elif count == 3:
        axes3.bar(level_state.index,level_state.values)
        for tick in axes3.get_xticklabels():
            tick.set_rotation(15)
    elif count == 4:
        axes4.bar(level_state.index,level_state.values)
        for tick in axes4.get_xticklabels():
            tick.set_rotation(15)
    elif count == 5:
        axes5.bar(level_state.index,level_state.values)
        for tick in axes5.get_xticklabels():
            tick.set_rotation(15)
    elif count == 6:
        axes6.bar(level_state.index,level_state.values)
        for tick in axes6.get_xticklabels():
            tick.set_rotation(15)
    count+=1



axes1.set_title(top_state[0])
axes2.set_title(top_state[1])
axes3.set_title(top_state[2])
axes4.set_title(top_state[3])
axes5.set_title(top_state[4])
axes6.set_title(top_state[5])

fig.tight_layout()

"""# Q9 : What is the top 10 companies for each title based on salaries (avg)?





"""

top_titles = (df.groupby("title").mean()["basesalary"]).sort_values(ascending = False).head(6)
top_titles = list(top_titles.index)
top_titles

fig = plt.figure(figsize=(14,14))

fig.suptitle("Top Companies for the Top Six Titles Based on Total Salary")
# fig.tight_layout()
axes1 = fig.add_subplot(321)
axes2 = fig.add_subplot(322)
axes3 = fig.add_subplot(323)
axes4 = fig.add_subplot(324)
axes5 = fig.add_subplot(325)
axes6 = fig.add_subplot(326)
count = 1
            
for i in top_titles:
    company_title = df[df["title"] == i]
    company_title = company_title.groupby("company").mean()["basesalary"].sort_values(ascending = False).head(5)
    # print(company_title)
    if count == 1:
        axes1.bar(company_title.index,company_title.values)
        for tick in axes1.get_xticklabels():
            tick.set_rotation(15)
    elif count == 2:
        axes2.bar(company_title.index,company_title.values)
        for tick in axes2.get_xticklabels():
            tick.set_rotation(15)
    elif count == 3:
        axes3.bar(company_title.index,company_title.values)
        for tick in axes3.get_xticklabels():
            tick.set_rotation(15)
    elif count == 4:
        axes4.bar(company_title.index,company_title.values)
        for tick in axes4.get_xticklabels():
            tick.set_rotation(15)
    elif count == 5:
        axes5.bar(company_title.index,company_title.values)
        for tick in axes5.get_xticklabels():
            tick.set_rotation(15)
    elif count == 6:
        axes6.bar(company_title.index,company_title.values)
        for tick in axes6.get_xticklabels():
            tick.set_rotation(15)
    count+=1



axes1.set_title(top_titles[0])
axes2.set_title(top_titles[1])
axes3.set_title(top_titles[2])
axes4.set_title(top_titles[3])
axes5.set_title(top_titles[4])
axes6.set_title(top_titles[5])

fig.tight_layout()

"""# Q10 : What is the relation between years of experience and the avg total year comp.?





"""

#Get rid of outliers in years of experience column
x1 = df1['yearsofexperience']
Lower_Fence, Upper_Fence = getBoxPlotFences(x1)

df1 = df1[(x1<=Upper_Fence) & (x1>Lower_Fence)]

#getting the average total yearly compensation to get the trend in years of experience
avg_sal_exp = (df1.groupby("yearsofexperience").mean()["totalyearlycompensation"])
avg_sal_exp

#show the plot to understand the trend
plt.plot(avg_sal_exp.index,avg_sal_exp.values)

# to view the grid in the plot.
plt.grid(True)

"""Question 11

What are the top 5 states based on base salaries (avg) for each gender? 
"""

# filtered_gender = df[(df['gender'] != "Unknown") & (df['gender'] != "Other")]
#Get rid of outliers in total yearly compensation and base salary column
p = df['totalyearlycompensation']
Lower_Fence, Upper_Fence = getBoxPlotFences(p)
df_fil = df[(p<=Upper_Fence) & (p>Lower_Fence)]

p1 = df_fil['basesalary']
Lower_Fence,Upper_Fence = getBoxPlotFences(p1)
df_fil_basesalary = df_fil[(p1<=Upper_Fence) & (p1>Lower_Fence)]

filtered_gender = df_fil_basesalary[(df_fil_basesalary['gender'] != "Unknown") & (df_fil_basesalary['gender'] != "Other")]

# Getting the average base salary for each state based on genders:
mean_salary_by_gender = filtered_gender.groupby(["state", 'gender'], as_index=False).basesalary.mean()

# Sorting the values in the decending order based on base salary.
sorted_mean_sal_by_gender = mean_salary_by_gender.sort_values(by="basesalary", ascending=False)

top5_salary_by_gender = sorted_mean_sal_by_gender.groupby('gender').head(5)

# Plotting the bar chart of the data
x_axis = np.arange(len(top5_salary_by_gender[top5_salary_by_gender["gender"] == 'Female']["state"]))

plt.figure(figsize=(14, 7))
plt.bar(x_axis-0.2, top5_salary_by_gender[top5_salary_by_gender["gender"] == 'Male']["basesalary"], 0.4, label="Male", color='cyan')
plt.bar(x_axis + 0.2, top5_salary_by_gender[top5_salary_by_gender["gender"] == 'Female']["basesalary"], 0.4, label="Female")
plt.xticks(x_axis ,list(top5_salary_by_gender[top5_salary_by_gender["gender"] == 'Female']["state"]), rotation=90)
plt.xlabel("States")
plt.ylabel("Average Base Salary")
plt.title("Top 5 states based on base salaries (avg) for each gender")
plt.legend()
plt.show()

"""Question 12:

What are the top 5 states with bonus (avg) for each gender? 
"""

p2 = df['bonus']
Lower_Fence,Upper_Fence = getBoxPlotFences(p2)
df_fil_bonus = df[(p2<=Upper_Fence) & (p2>Lower_Fence)]

fil_gen_by_bonus = df_fil_bonus[(df_fil_bonus['gender'] != "Unknown") & (df_fil_bonus['gender'] != "Other")]

avg_bonus_by_gender = fil_gen_by_bonus.groupby(["state", 'gender'], as_index=False)["bonus"].mean()

# Sorting the values in the decending order based on base salary.
sorted_avg_bonus_by_gender = avg_bonus_by_gender.sort_values(by="state", ascending=False)

# Getting top 5 salary by gender:
top5_bonus_by_gender = sorted_avg_bonus_by_gender.groupby('gender').head(5)

male_bonus = top5_bonus_by_gender[top5_bonus_by_gender["gender"] == 'Male']["bonus"]
female_bonus = top5_bonus_by_gender[top5_bonus_by_gender["gender"] == 'Female']["bonus"]

X_axis = np.arange(len(top5_bonus_by_gender[top5_bonus_by_gender["gender"] == 'Female']["state"]))

plt.figure(figsize=(14, 7))
plt.bar(X_axis - 0.2, male_bonus , 0.4, label="Male", color='cyan')
plt.bar(X_axis + 0.2, female_bonus , 0.4, label="Female")
plt.xticks(X_axis ,list(top5_bonus_by_gender[top5_bonus_by_gender["gender"] == 'Female']["state"]), rotation=90)
plt.xlabel("States")
plt.ylabel("Average Bonus")
plt.title("Top 5 states with bonus (avg) for each gender")
plt.legend()
# plt.show()

"""Question 13:

What is the top degree level for the top 5 states based on salary (avg)?
"""

cond_Unknow = df['Education'] != 'UnKnown'

res = df.loc[cond_Unknow,['state','Education','basesalary']]

Lower_Fence,Upper_Fence = getBoxPlotFences(res['basesalary'].copy())
print(f'Lower_Fence: {Lower_Fence},Upper_Fence:{Upper_Fence}')

res = res.copy()
res.loc[res['basesalary'] > Upper_Fence,'basesalary'] = Upper_Fence
res.loc[res['basesalary'] < Lower_Fence,'basesalary'] = Lower_Fence

#get valid states with >= 5 records
ValidStates = res.groupby('state').size()
ValidStates = ValidStates[ValidStates >= 5]
ValidStates = list(ValidStates.index)

cond_validStates = res['state'].apply(lambda x:x in ValidStates)
res = res[cond_validStates]

#get top 5 states bases on the avg of basesalary
top5_df = res.groupby('state').mean('basesalary').sort_values('basesalary',ascending=False)['basesalary'].head(5)
top5 = list(top5_df.index)

#set filters to get the top 5 states & to execlude 'UnKnown' Race (it does not make sense to be presented)
cond = res['state'].apply(lambda x:x in top5)

#get the results based on the filters
res = res.loc[cond,['state','Education']]
res = res.groupby(['state','Education']).size()
res = res / res.groupby('state').sum() # get percentage of each race

#Convert to DF
res_df = res.to_frame(name='cnt')

#Pivot DF
res_df = res_df.pivot_table('cnt',['state'],'Education')
res_df.reset_index(inplace=True)

#Plot
res_df.plot(x='state',y=list(res_df.columns).remove('state'),kind='bar',figsize=(12,8),
            title='Race (AVG Salary) Trends among the top 5 States (Only Records with Reported Race)',xlabel='Education',ylabel='Percentage')

"""Question 14:

What is the relation between gender and title (based on avg salary)?
"""

gender_avg_sal_by_title = filtered_gender.groupby(['title','gender'], as_index=False).basesalary.mean()

gender_title = gender_avg_sal_by_title.groupby(['title']).head()

male = gender_title[gender_title["gender"] == 'Male']["basesalary"]
female = gender_title[gender_title["gender"] == 'Female']["basesalary"]

X_axis = np.arange(len(gender_title[gender_title["gender"] == 'Female']["title"]))

plt.figure(figsize=(14, 6))
plt.bar(X_axis - 0.2, male , 0.4, label="Male", color='cyan')
plt.bar(X_axis + 0.2, female , 0.4, label="Female")
plt.xticks(X_axis , list(gender_title[gender_title["gender"] == 'Female']["title"]) , rotation=90)
plt.title("Relationship Between Gender and Title based on Average Base Salary")
plt.xlabel("Title")
plt.ylabel("Avg base Salary")
plt.legend()
plt.show()

"""# Classification

# Predict Total totalyearlycompensation Range (Low,Mid,High)
## using SVM
"""

df1 = df.copy()
df1.drop(['timestamp','location', 'level', 'tag', 'otherdetails', 'cityid', 'dmaid', 'rowNumber', 'Masters_Degree', 'Bachelors_Degree',
         'Doctorate_Degree', 'Highschool', 'Some_College', 'Race_Asian', 'Race_White', 'Race_Two_Or_More', 'Race_Black', 
         'Race_Hispanic' ], axis = 1, inplace= True)

from sklearn.preprocessing import LabelEncoder, StandardScaler

label_encoder = LabelEncoder()

#converting strings to numeric values
df1['gender'] = label_encoder.fit_transform(df1['gender'].values)
df1['title'] = label_encoder.fit_transform(df1['title'].values)
df1['Education'] = label_encoder.fit_transform(df1['Education'].values)
df1['Race'] = label_encoder.fit_transform(df1['Race'].values)
df1['city'] = label_encoder.fit_transform(df1['city'].values)
df1['state'] = label_encoder.fit_transform(df1['state'].values)
df1['company'] = label_encoder.fit_transform(df1['company'].values)

df_classification1 = df1.copy()
df_classification1['basesalary'] = StandardScaler().fit_transform(df_classification1[['basesalary']])
df_classification1['stockgrantvalue'] = StandardScaler().fit_transform(df_classification1[['stockgrantvalue']])
df_classification1['bonus'] = StandardScaler().fit_transform(df_classification1[['bonus']])

#copy totalyearlycompensation column
df_classification1['totalyearlycompensation_numeric'] = df_classification1['totalyearlycompensation']
# categorize the totalyearlycompensation
df_classification1['totalyearlycompensation'] = pd.cut(df_classification1['totalyearlycompensation_numeric'], bins=[0, 155240, 305240, np.inf], include_lowest=True, labels=['low', 'mid', 'high'])

listcol = list(df_classification1.columns)
listcol.remove('totalyearlycompensation_numeric')
df_classification1 = df_classification1[listcol]

listcol.remove('totalyearlycompensation')
X = df_classification1[ listcol].values

Y = df_classification1['totalyearlycompensation'].values

df_classification1

#implementation of Support Vector Machine
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn import metrics



X_train , X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2,random_state = 10,stratify = Y)

clf = SVC(C=1.0, kernel='linear', gamma = 'auto').fit(X_train, y_train)

y_pred = clf.predict(X_test)

print("Accuracy:",metrics.accuracy_score(y_test, y_pred))

for i in range(20):
  print(y_test[i],' | ',y_pred[i])

"""## Salary Value Prediction
### using LinearRegression

## Predict totalyearlycompensation
"""

df_classification2 = df1.copy()

listcol = ['company','title','basesalary','bonus','state']
X = df_classification2[listcol].values
Y = df_classification2['totalyearlycompensation'].values

X.shape,Y.shape

df_classification2

from sklearn.linear_model import LinearRegression

X_train , X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2,random_state = 10)

reg = LinearRegression(fit_intercept=True, normalize=True, n_jobs=-1).fit(X_train, y_train)

print('score',reg.score(X_test, y_test))
print('')

from sklearn.metrics import explained_variance_score
#The explained_variance_score computes the explained variance regression score.
y_pred = reg.predict(X_test)
explained_variance_score(y_test, y_pred)

for i in range(20):
  print(y_test[i],' | ',round(y_pred[i]))

